// Fill out your copyright notice in the Description page of Project Settings.


#include "Subsystems/Subsystem_AssetHandler.h"
#include "Engine/World.h"
#include "Interfaces/I_Common.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "IPlatformFilePak.h"
#include "LuaBlueprintFunctionLibrary.h"
#include "LuaInterface.h"
#include "LuaSettings.h"
#include "OmegaSettings.h"
#include "OmegaGameCore.h"
#include "Functions/F_Common.h"
#include "HAL/PlatformFilemanager.h"
#include "Misc/Paths.h"
#include "Misc/PackageName.h"


void UOmegaSubsystem_AssetHandler::ClearSortedAssets_All()
{
	SortedAssets.Empty();
}

TArray<UObject*> UOmegaSubsystem_AssetHandler::GetSortedAsset_All()
{
	TArray<UObject*> out;
	TArray<FString> asset_list;
	SortedAssets.GetKeys(asset_list);
	for(FString tempName : asset_list)
	{
		out.Add(GetSortedAsset_FromLabel(tempName));
	}
	return  out;
}

UObject* UOmegaSubsystem_AssetHandler::GetSortedAsset_FromLabel(const FString& Name)
{
	if(SortedAssets.Contains(Name))
	{
		return SortedAssets[Name];
	}
	return nullptr;
}

void UOmegaSubsystem_AssetHandler::Register_SortedAsset(UObject* Asset, FString Name, bool bOverride)
{
	if(Asset && (!SortedAssets.Contains(Name) || bOverride))
	{
		SortedAssets.Add(Name,Asset);
	}
}


void UOmegaSubsystem_AssetHandler::GenerateLuaTableDataAssets()
{
	TArray<UPrimaryDataAsset*> _list;
	TArray<FLuaValue> _tableKeys;
	
	TMap<FName,TSubclassOf<UPrimaryDataAsset>> _TableDataAssets;
	
	for (auto _preset : GetMutableDefault<ULuaSettings>()->Settings_Presets)
	{
		if (ULuaSettings_Preset* p=_preset.LoadSynchronous())
		{
			TArray<FName> _TempKeys;
			p->AutoGeneratedDataAssets.GetKeys(_TempKeys);
			for (FName n : _TempKeys)
			{
				_TableDataAssets.Add(n,p->AutoGeneratedDataAssets[n]);
			}
		}
	}
	
	TArray<FName> _TempKeys;
	_TableDataAssets.GetKeys(_TempKeys);
	
	for (FName n : _TempKeys)
	{
		//get Lua table from found DA key
		FLuaValue current_table=ULuaBlueprintFunctionLibrary::LuaGetGlobal(this,nullptr,n.ToString());
		if (!current_table.IsNil())
		{
			if (TSubclassOf<UPrimaryDataAsset> daC = _TableDataAssets[n])
			{
				//iterate though each table key to generate data assets
				for (FLuaValue gKey : ULuaBlueprintFunctionLibrary::LuaTableGetKeys(current_table))
				{
					UObject* _target_object;
					//if asset key already exists, just updated it
					bool outcome;
					if (UObject* _tempObject=UOmegaGameFrameworkBPLibrary::GetAsset_FromPath(gKey.ToString(),daC,outcome))
					{
						_target_object=_tempObject;
					}
					//else generate from lua table if new.
					else
					{
						FString _ObjectName=n.ToString()+"."+gKey.ToString();
						_target_object=NewObject<UObject>(this,daC,*_ObjectName);
						Register_SortedAsset(_target_object,gKey.ToString(),true);
					}
					
					//finish up by setting lua values;
					if (_target_object && _target_object->GetClass()->ImplementsInterface(ULuaInterface::StaticClass()))
					{
						FLuaValue _inVal=current_table.GetField(gKey.ToString());
						if (UOmegaGameCore* set=GetMutableDefault<UOmegaSettings>()->GetGameCore())
						{
							set->Lua_OnObjectGeneration(_target_object,gKey,_inVal);
						}
						ILuaInterface::Execute_SetKey(_target_object,gKey);
						ILuaInterface::Execute_SetValue(_target_object,_inVal,"");
					}
				}
			}
		}
	}
}

TArray<UObject*> UOmegaAssetHandlerFunctions::GetSortedAssets_OfClass(UClass* Class)
{
	TArray<UObject*> out;
	for (auto* TempAsset : GEngine->GetEngineSubsystem<UOmegaSubsystem_AssetHandler>()->GetSortedAsset_All())
	{
		if(TempAsset && TempAsset->GetClass()->IsChildOf(Class))
		{
			out.Add(TempAsset);
		}
	}
	return out;
}

TArray<UObject*> UOmegaAssetHandlerFunctions::GetSortedAssets_OfCategory(FGameplayTag CategoryTag, UClass* Class)
{
	TArray<UObject*> out;
	for (auto* TempAsset : GEngine->GetEngineSubsystem<UOmegaSubsystem_AssetHandler>()->GetSortedAsset_All())
	{
		if(TempAsset && (TempAsset->GetClass()->IsChildOf(Class) || !Class) && TempAsset->GetClass()->ImplementsInterface(UGameplayTagsInterface::StaticClass()))
		{
			FGameplayTag TempAssetTag = IGameplayTagsInterface::Execute_GetObjectGameplayCategory(TempAsset);
			if(TempAssetTag.MatchesTag(CategoryTag))
			{
				out.Add(TempAsset);
			}
		}
	}
	return out;
}

TArray<UObject*> UOmegaAssetHandlerFunctions::GetSortedAssets_WithTags(FGameplayTagContainer Tags, UClass* Class)
{
	TArray<UObject*> out;
	for (auto* TempAsset : GEngine->GetEngineSubsystem<UOmegaSubsystem_AssetHandler>()->GetSortedAsset_All())
	{
		if(TempAsset && (TempAsset->GetClass()->IsChildOf(Class) || !Class) && TempAsset->GetClass()->ImplementsInterface(UGameplayTagsInterface::StaticClass()))
		{
			if(IGameplayTagsInterface::Execute_GetObjectGameplayTags(TempAsset).HasAllExact(Tags))
			{
				out.Add(TempAsset);
			}
		}
	}
	return out;
}

UObject* UOmegaAssetHandlerFunctions::GetSortedAsset_FromName(const FString& Name, UClass* Class, bool& result)
{
	
	UObject* _temp=GEngine->GetEngineSubsystem<UOmegaSubsystem_AssetHandler>()->GetSortedAsset_FromLabel(Name);
	if(_temp && (!Class || _temp->GetClass()->IsChildOf(Class)))
	{
		result=true;
		return nullptr;
	}
	result=false;
	return nullptr;
}
